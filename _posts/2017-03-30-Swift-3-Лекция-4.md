## Функции

Как се справяме с големите програми?

Преди време, когато компютрите са били големи чудовищини машини, отнемащи пространство повече от една нормална стая (~15 м. кв.), изчислителната им мощ е била хиляди пъти по-малка от тази на съвременните "умни" телефони. Размера на оперативната им  памет е бил малък, много по-малък от 1 МB (за справка, днешните домашни компютри имат средно около 4 до 8 GB, 1GB = 1024 MB). Това налага ограничение на размера на програмите които могат да се пишат, за да могат да се управляват от хардуера. Трудността в писането на компютърни програми по това време идва и от липсата на хубави програмни езици. Какво поражда липсата на хубави програмни езици по това време - липсата на [компилатори](https://en.wikipedia.org/wiki/History_of_compiler_construction#First_compilers). т.е. преди всичко се е пишело на по-ниско ниво. Отнемало много време и е било трудно да се следи за корекността на програмите, понеже кодът е бил сложен за четене и анализ от програмистта, но пък е бил по-лесен за превод към устройстовото. Днес инструкциите, до които се превежда написаният от нас код на Swift, се наричат инструкции на ниско ниво, асемблер и машинен език. Те остават скрити за съвременният широк кръг от програмисти, но това са били първите варианти на езиците за прогрмаиране.
С течение на времето, сложността на програмите започва да нараства и нуждата от нови парадигми в програмирането ражда нови езици и начини на организране на код-а. От програмиране на Асемблер се минава към проргамни езици които се компилират. Има движение което издига функционалните езици. Това е друга категория програмни езици, която поритежава хубави логически свойства в сравнение с класическите императивни езици. Последните еволюират, като се появява Обектно ориентираният подход (C++). Можем да говорим много за [историята на програмните езици](https://en.wikipedia.org/wiki/History_of_programming_languages), но е важно да отбележим, че се заражда едно движение за презиползване на вече написаните неща. Т.е. появава се процес по надграждане, какъвто има и в научните среди, във различните индустрии. Натрупват се знания, които тласкат прогреса и човечеството напред.

В тази статия ще се запознаем с функциите в Swift, които ни позволяват да преизползваме вече написан код в нашите програми. Те ни дават възможността да решим общ проблем еднократно и в последствие да приложим решението на много места, спестявайки време, съкращавайки дължината на програмата, подобрявайки нейната корекност (по-малко код => по-малка вероятност за бъгове).

Как се дефинират функции в Swift? Ще започнем с базов пример - функция, която изпълнява набор от стъпки. В последствие ще разширим примера, докато достигнем пълният потенциал на функциите като изразно средство.

```swift
//Нека да напишем първата функция, която агрегира няколко действия.
func severalActions() {
	print("Action 1")
	print("Action 2")
	print("Action 3")
}

//тук ще активираме нашата функция. Може да мислим че я извикваме (call)
severalActions()
severalActions()
```

Примерът по-горе прави 3 последователни извиквания на функцията `print()` с различни стойности. Дефиницията на функцията сама по себе си, определя какво ще прави дадена функция, но тя не се активира автоматично. Трябва да направим правилното извикване.

За да формализираме нещата ще опишем общият вариант на функция в Swift.

```swift
func functionName(labelName variableName:String) -> String {
	let returnedValue = variableName + " was passed"
	return returnedValue
}

//ето и извикването на функцията
let resultOfFunctionCall = functionName(labelName: "Nothing")
```

Всичко започва с думата `func`, която е запазената дума в Swift за деклариране на функция. След това следва името на функцията - `functionName`, като тук следваме правилата за име на променлива, като внимаваме да няма многозначност (т.е. да не се повтаря името с име на променлива и някоя друга запазена дума). Продължаваме с параметрите, които може да са повече от един. Всеки параметър има име, което се използва при извикване на функцията (label) и име (variable), с което се среща в тялото на функцията. Следва запазеният символ `->` и типа на връщания резултат. После в `{ }` е отделено тялото на функцията, като трябва да има `return` случай, който оказва, каква стойност ще връща функцията (може да е конкретна стойност от обявеният по-горе тип, може да е и променлива или израз, стига оценяването му да дава правилният тип стойност).

Ако погледнем приемра по-горе виждаме, че функцията ще връща `String` стойност. Тя получава един параметър, който трябва да бъде подаден със своето име `labelName:`. Резултата от извикването на функцията се запомня в константата `resultOfFunctionCall` и е от тип __String__, както и типа на връщания резултат от функцията.

Нека да представим няколко разновидности на тази функция.

```swift
//вижте разновидностите на функцията
	
//ако променим името на аргумента swift счита това за нова различна функция. Т.е. имената на аргумента
func functionName(labelNameNew variableName:String) -> String {
	let returnedValue = variableName + " NEW was passed"
	return returnedValue
}

//когато изпуснем името на аргумента, името на променливата се изпозлва за негово име. т.е. двете съвпадат
func functionName(variableName:String) -> String {
	let returnedValue = variableName + " was passed. v2"
		return returnedValue
	}
```

_Какво ни прави впечатление?_ Променливите имат имена.

Имената на променливите са нещо нетрадиционно за класическите езици като Java, C, C++. Ако искаме да симулираме старото поведение, трябва да използваме `_`(undescore) - долна черта (wildcard), за да маркираме името на параметара, като празен. Вече, сме запознати с този символ. Той влизаше в полза, когато запазваме стойността в променлива, която няма участие в кода, който следва. Подобна е и логиката тук. Не ни трябва име на параметъра. 
_Какви са останалите случаи, когато имаме параметър с име?_ Името на параметъра, участва в крайното име на функцията. Това позволява, да имаме функции с еднакви имена, но с различни имена на параметри (примерите следват). (В другите езици, е важно и типовете да са различни или броят на променливите да е различен. т.е. за да имаме правилен overloading. - Компилатора подбира правилната функция на базата на типовете на данните, които са използвани при извикването й.)

Нека сега да погледнем към различните типове функции:

### 1. функции без параметри, които връщат резултат

```swift
//функция, която връша резултат
func seven() -> Int {
	return 7
}
		
let s = seven()
print("Това е числото \(s).")
```

Всяка функция, може да връща резултат от определен тип или да не връща резултат. При дефинирането й ние решаваме това. В примера, по-горе става ясно, че функцията връща резултат, но той не зависи от парамтерите, в конкретния случая. Често, връщаният резултат зависи от параметрите, но понякога зависи от текущото състояние на системата (устройството, на което се изпълнява кодът). Примерно: можем да напишем функция, която връща различни стойности, в зависимост дали кодът се изпълнява на мобилно устройство или на настолен компютър. 

### 2. функция с параметри (един или повече, но без да връща резултат)

```swift
//сума на две числа
func printSum(a:Int, b:Int) {
	print("Sum \(a) + \(b) = \(a + b)")
}
		
//извикване на функцията
printSum(a:3, b:5)
```
Тези функции се използват да изпълнят някакво действие или да представят информация на потребителя. Хубаво е да използваме имената на параметрите, за да можем да представим по-изчерпателно, какво ще прави тази функция, пред разработчика, в момента и на използване.

_Публичните функции, които можем да използваме при разработката на мобилни приложения за iOS следват това правило и са един прекрасен пример, как е правилно да се именуват функциите и параметрите, така че да няма излишни думи, но и да е напълно разбираемо._

### 3. функция с няколко резултата

За да върнем повече от един тип резултат, ние трябва да използваме N-торки (tuples). Това са пакетчета от няколко различни типа данни, които са окомплектовани в едно. Те може да имат имена, асоциирани с всеки член на N-торката. Ако такива имена липсват, тогава можем да използваме индексите. Данните в пакетчето се предават по стойност. Това означава, че те се копират в паметта (в следващата лекция ще разгледаме разликата между референтините типове (reference types) и тези, които се копират по стойност (value types)). Нека да видим няколко примера, за да знаем как да ги ползваме:

```swift
/* N-торки */
let person = (name: "Иван", familyName: "Петров", age: 25)
let p:(String, String, age: Int)? = person
print("Здравей, \(person.name)!")
		
print("Здравей, г-н \(person.familyName)!")
		
print("Здравей, г-н \(person.1)!")
if let pp = p, pp.age > 20 {
	print("Г-н \(pp.1), Вие сте на \(pp.age) години.")
}
```
	
Ето и пример за функция, която ги използва активно.

```swift
func maxItemIndex(numbers:[Int]) -> (item:Int, index:Int) {
    	var index = -1
	var max = Int.min
    
	for (i, val) in numbers.enumerated() {
		if max < val {
	          	max = val
          		index = i
        	}
	}
    	
    	return (max, index)
}
		
let maxItemTuple = maxItemIndex(numbers: [12, 2, 6, 3, 4, 5, 2, 10])
if maxItemTuple.index >= 0 {
	print("Max item is \(maxItemTuple.item).")
}
```

### 4. функция с __inout__ параметри 

```swift
func updateVar(oldVariable x: inout Int, newValue: Int = 5) {
	x = newValue
}

var ten = 10
print(ten)
updateVar(oldVariable: &ten, newValue: 15)
print(ten)
```

В примера, по-горе, виждаме още един начин, как да връщаме "резултат" от функция. Трябва да спазим някои основни правила. __inout__  се поставя преди типа параметъра `x: inout Int`, когато дефинираме функцията. В момента на извикване на функцията можем да подаваме само променливи, където се изискват __inout__ параметри. Това е нужно, за да може функцията да запише стойността в тази част от паметта. Това се отбелязва визуално с `&` пред името на променливата.
	
Интересно е да отбележим, че всички променливи, които са част от декларацията на функцията и не са __inout__, са константи. Т.е. не може, в тялото на функцията, да бъде присвоена стойност, освен ако не са обявени като __inout__. Ето и един пример:

```swift
var sumAB:Int = 0
sum(a:3, b:4, in:&sumAB)
```

Променливата, `sumAB` трябва да е инициализирана, преди да се подаде като параметър. Предаването й става по референция. В действителност, се подава мястото в паметта, което може да бъде използвано от функцията, да запише стойсност.

Кои функции са по-добри? Тези, които връщат няколко резултата или тези които променят стойностите на параметрите си? И двата случая имат предимства и недостатъци. Тези, които връщат няколко параметъра, използват повече място в паметта, но не изискват допълнителна подготовка. Подаваме си параметрите и си получаваме резултата. Те не променят "средата" в която се изпълняват. 
Алтернативата, функции с __inout__ параметри, могат да променят стойността на параметрите си. Трябва да сме внимателни, да подаваме правилните неща (тук компилатора ни помага). Също така, трябва да знаем, кога една функция, може да направи промяна с данните и да отчитаме тази промяна. Тази техника има предимство, ако се борави с големи обеми от данни. Ще разгледаме доста примери след като се запознаем с референтните типове през следващите лекции.

